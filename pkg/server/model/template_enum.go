// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package model

import (
	"fmt"
	"strings"
)

const (
	// OriginNone is a Origin of type None.
	OriginNone Origin = iota
	// OriginPredefined is a Origin of type Predefined.
	OriginPredefined
	// OriginSystem is a Origin of type System.
	OriginSystem
)

var ErrInvalidOrigin = fmt.Errorf("not a valid Origin, try [%s]", strings.Join(_OriginNames, ", "))

const _OriginName = "nonepredefinedsystem"

var _OriginNames = []string{
	_OriginName[0:4],
	_OriginName[4:14],
	_OriginName[14:20],
}

// OriginNames returns a list of possible string values of Origin.
func OriginNames() []string {
	tmp := make([]string, len(_OriginNames))
	copy(tmp, _OriginNames)
	return tmp
}

var _OriginMap = map[Origin]string{
	OriginNone:       _OriginName[0:4],
	OriginPredefined: _OriginName[4:14],
	OriginSystem:     _OriginName[14:20],
}

// String implements the Stringer interface.
func (x Origin) String() string {
	if str, ok := _OriginMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Origin(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Origin) IsValid() bool {
	_, ok := _OriginMap[x]
	return ok
}

var _OriginValue = map[string]Origin{
	_OriginName[0:4]:                    OriginNone,
	strings.ToLower(_OriginName[0:4]):   OriginNone,
	_OriginName[4:14]:                   OriginPredefined,
	strings.ToLower(_OriginName[4:14]):  OriginPredefined,
	_OriginName[14:20]:                  OriginSystem,
	strings.ToLower(_OriginName[14:20]): OriginSystem,
}

// ParseOrigin attempts to convert a string to a Origin.
func ParseOrigin(name string) (Origin, error) {
	if x, ok := _OriginValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _OriginValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Origin(0), fmt.Errorf("%s is %w", name, ErrInvalidOrigin)
}

const (
	// TemplateFieldsUuid is a TemplateFields of type Uuid.
	TemplateFieldsUuid TemplateFields = iota
	// TemplateFieldsName is a TemplateFields of type Name.
	TemplateFieldsName
	// TemplateFieldsSummary is a TemplateFields of type Summary.
	TemplateFieldsSummary
	// TemplateFieldsFlow is a TemplateFields of type Flow.
	TemplateFieldsFlow
	// TemplateFieldsInputs is a TemplateFields of type Inputs.
	TemplateFieldsInputs
	// TemplateFieldsOrigin is a TemplateFields of type Origin.
	TemplateFieldsOrigin
	// TemplateFieldsCreated is a TemplateFields of type Created.
	TemplateFieldsCreated
	// TemplateFieldsUpdated is a TemplateFields of type Updated.
	TemplateFieldsUpdated
)

var ErrInvalidTemplateFields = fmt.Errorf("not a valid TemplateFields, try [%s]", strings.Join(_TemplateFieldsNames, ", "))

const _TemplateFieldsName = "uuidnamesummaryflowinputsorigincreatedupdated"

var _TemplateFieldsNames = []string{
	_TemplateFieldsName[0:4],
	_TemplateFieldsName[4:8],
	_TemplateFieldsName[8:15],
	_TemplateFieldsName[15:19],
	_TemplateFieldsName[19:25],
	_TemplateFieldsName[25:31],
	_TemplateFieldsName[31:38],
	_TemplateFieldsName[38:45],
}

// TemplateFieldsNames returns a list of possible string values of TemplateFields.
func TemplateFieldsNames() []string {
	tmp := make([]string, len(_TemplateFieldsNames))
	copy(tmp, _TemplateFieldsNames)
	return tmp
}

var _TemplateFieldsMap = map[TemplateFields]string{
	TemplateFieldsUuid:    _TemplateFieldsName[0:4],
	TemplateFieldsName:    _TemplateFieldsName[4:8],
	TemplateFieldsSummary: _TemplateFieldsName[8:15],
	TemplateFieldsFlow:    _TemplateFieldsName[15:19],
	TemplateFieldsInputs:  _TemplateFieldsName[19:25],
	TemplateFieldsOrigin:  _TemplateFieldsName[25:31],
	TemplateFieldsCreated: _TemplateFieldsName[31:38],
	TemplateFieldsUpdated: _TemplateFieldsName[38:45],
}

// String implements the Stringer interface.
func (x TemplateFields) String() string {
	if str, ok := _TemplateFieldsMap[x]; ok {
		return str
	}
	return fmt.Sprintf("TemplateFields(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TemplateFields) IsValid() bool {
	_, ok := _TemplateFieldsMap[x]
	return ok
}

var _TemplateFieldsValue = map[string]TemplateFields{
	_TemplateFieldsName[0:4]:                    TemplateFieldsUuid,
	strings.ToLower(_TemplateFieldsName[0:4]):   TemplateFieldsUuid,
	_TemplateFieldsName[4:8]:                    TemplateFieldsName,
	strings.ToLower(_TemplateFieldsName[4:8]):   TemplateFieldsName,
	_TemplateFieldsName[8:15]:                   TemplateFieldsSummary,
	strings.ToLower(_TemplateFieldsName[8:15]):  TemplateFieldsSummary,
	_TemplateFieldsName[15:19]:                  TemplateFieldsFlow,
	strings.ToLower(_TemplateFieldsName[15:19]): TemplateFieldsFlow,
	_TemplateFieldsName[19:25]:                  TemplateFieldsInputs,
	strings.ToLower(_TemplateFieldsName[19:25]): TemplateFieldsInputs,
	_TemplateFieldsName[25:31]:                  TemplateFieldsOrigin,
	strings.ToLower(_TemplateFieldsName[25:31]): TemplateFieldsOrigin,
	_TemplateFieldsName[31:38]:                  TemplateFieldsCreated,
	strings.ToLower(_TemplateFieldsName[31:38]): TemplateFieldsCreated,
	_TemplateFieldsName[38:45]:                  TemplateFieldsUpdated,
	strings.ToLower(_TemplateFieldsName[38:45]): TemplateFieldsUpdated,
}

// ParseTemplateFields attempts to convert a string to a TemplateFields.
func ParseTemplateFields(name string) (TemplateFields, error) {
	if x, ok := _TemplateFieldsValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _TemplateFieldsValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return TemplateFields(0), fmt.Errorf("%s is %w", name, ErrInvalidTemplateFields)
}
